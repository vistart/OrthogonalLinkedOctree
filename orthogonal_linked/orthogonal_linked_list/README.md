# 多维度正交链表

以下内容为此项目的实现细节。

## 空间元素坐标化（Coordinate.h）

“正交链表”指向的每个元素均具备空间坐标，每个元素都可以使用特定的坐标定位。

默认情况下，每个坐标系从零开始。每个坐标轴的范围均相同，即坐标范围形状为正方形（正方体或超正方体）。

“正交链表”使用 C++ 的 unordered_map 作为存储元素指针的数据结构。元素的坐标是 unordered_map 的键，指针是 unordered_map 的值。

由于每个坐标轴的范围均相同，因此 unordered_map 的表示范围要平均分配给每个坐标轴。在 64 位计算机中，unordered_map 将键的长度定义为 64 位。若为二维空间，则每个坐标轴可获得 32 位表示范围；若为三维空间，则每个坐标轴获得 21 位表示范围，剩余最高 1 位不使用；若为四维空间，则每个坐标轴获得 16 位表示范围。

如果实际坐标的表示范围超出 unordered_map 给每个坐标轴分配的范围，则需要截取低位（即“低位交叉”），以避免相邻坐标产生散列堆积现象。

选用该数据结构的理由如下：

1. unordered_map 可以视作散列表，可以实现 O(1) 的访问时间复杂度。
2. “正交链表”元素保存的是指向实际内容的指针，而非具体元素。因为指针可以表示“空”，代表此坐标没有对应元素。由于指针类型的长度固定，所以 unordered_map 的尺寸可以根据其容纳数量上限轻易计算出实际占用空间。其空间复杂度为 O(n)，n为指针的数量。

### 简要使用说明

- TBD

## 空间元素链表化（LinkedCoordinate.h）

在给“正交链表”表示空间的每个元素赋以坐标后，我们只能实现随机访问某个坐标，并判断当前坐标是否存在元素，但无法高效找出相邻元素。为了解决这个问题，我们需要将空间元素沿坐标轴从头到尾和从尾到头链接起来，才能实现接近 O(1) 时间复杂度访问沿坐标轴方向的相邻元素。

为了高效查找某个元素的相邻元素，我们需要在前述空间元素坐标化的基础上新增定义元素相对每个维度方向的近邻指针，指向某个维度的前驱和后继元素的坐标。因为要保存每个维度的前驱和后继元素坐标，因此每个元素的相邻坐标的个数为维度数的 2 倍。

例如，在三维空间下，每个元素有六个方向的近邻，因此需要 6 个坐标空间用于保存三个维度方向前后近邻元素的坐标。

另一方面，为了保证能从头到尾和从尾到头都可以实现遍历，我们还需要为每个维度准备“头（head）”和“尾（tail）”指针，以保证从头或从尾皆可以接近 O(1) 的时间复杂度找到当前维度的第一个元素。所有维度的“头”和“尾”指针构成指针组。这两类指针的类型同为相邻元素坐标。初始状态下，这两类指针组的前驱与后继均为 nullptr，以及当前头尾指针所夹区间内没有元素。

以二维空间为例：TBD

以三维空间为例：TBD
